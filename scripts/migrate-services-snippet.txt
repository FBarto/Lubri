import fs from 'fs';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { SyncService } from '@/lib/syncService';

const prisma = new PrismaClient();

const LEGACY_DIR = path.join(process.cwd(), '../Base de datos anterior');

// ... (previous helper functions: parseRow, parseValuesFromContent)

// Robust parse that handles multi-line INSERTs
function parseValuesFromContent(content: string, tableName: string): string[][] {
    const values: string[][] = [];
    const regex = new RegExp(`INSERT INTO \`?${tableName}\`?[\\s\\S]*?VALUES\\s*([\\s\\S]*?);`, 'gi');

    let match;
    while ((match = regex.exec(content)) !== null) {
        const valuesBlock = match[1];
        let depth = 0;
        let start = 0;
        let inQuote = false;

        for (let i = 0; i < valuesBlock.length; i++) {
            const char = valuesBlock[i];
            if (char === "'" && (i === 0 || valuesBlock[i - 1] !== '\\')) {
                inQuote = !inQuote;
            }
            if (!inQuote) {
                if (char === '(') {
                    if (depth === 0) start = i + 1;
                    depth++;
                } else if (char === ')') {
                    depth--;
                    if (depth === 0) {
                        const rowStr = valuesBlock.substring(start, i);
                        values.push(parseRow(rowStr));
                    }
                }
            }
        }
    }
    return values;
}

function parseRow(rowStr: string): string[] {
    const result: string[] = [];
    let current = '';
    let inQuote = false;

    for (let i = 0; i < rowStr.length; i++) {
        const char = rowStr[i];
        if (char === "'" && (i === 0 || rowStr[i - 1] !== '\\')) {
            inQuote = !inQuote;
        } else if (char === ',' && !inQuote) {
            result.push(current.trim().replace(/^'|'$/g, ''));
            current = '';
        } else {
            current += char;
        }
    }
    result.push(current.trim().replace(/^'|'$/g, ''));
    return result;
}

// ... (migrateClients, migrateVehicles, migrateProducts as before)

async function migrateServices() {
    console.log('Migrating History (Services)...');
    const content = fs.readFileSync(path.join(LEGACY_DIR, 'srerice.sql'), 'utf-8');
    const rows = parseValuesFromContent(content, 'servicios');

    // Create a generic service for legacy records
    const legacyService = await prisma.service.upsert({
        where: { name: 'Servicio Hist贸rico' }, // Assuming name is unique? Service model doesn't have unique name. 
        // Need to findFirst.
        update: {},
        create: {
            name: 'Servicio Hist贸rico',
            category: 'General',
            duration: 0,
            price: 0,
            active: true
        }
    });

    // Workaround for upsert if name not unique:
    // Actually Service model: name String. No unique constraint.
    // So upsert on ID? We don't have ID.
    // Better: findFirst, if not create.
    let serviceRef = await prisma.service.findFirst({ where: { name: 'Servicio Hist贸rico' } });
    if (!serviceRef) {
        serviceRef = await prisma.service.create({
            data: {
                name: 'Servicio Hist贸rico',
                category: 'General',
                duration: 0,
                price: 0,
                active: true
            }
        });
    }

    let count = 0;
    for (const row of rows) {
        // id, patente, Fecha, kilometros, proxServ, Faire, Faceite, Fcombustible, Fhabitaculo, Aceite, Aceite2, GrasaCaja, GrasaDif, hidraulico, Varios, observaciones, Varios2, Varios3
        // Indices:
        // 0: id
        // 1: patente
        // 2: Fecha
        // 3: kilometros
        // 4: proxServ
        // 5..17: Details

        if (row.length < 5) continue;

        const patente = row[1];
        if (!patente) continue;

        const dateStr = row[2]; // YYYY-MM-DD
        const mileage = parseInt(row[3]) || 0;

        // details
        let notes = '';
        const fields = ['Faire', 'Faceite', 'Fcombustible', 'Fhabitaculo', 'Aceite', 'Aceite2', 'GrasaCaja', 'GrasaDif', 'hidraulico', 'Varios', 'observaciones', 'Varios2', 'Varios3'];
        // Indices 5 to 17
        for (let i = 0; i < fields.length; i++) {
            const val = row[i + 5];
            if (val && val !== 'NULL' && val.trim() !== '') {
                notes += `${fields[i]}: ${val}\n`;
            }
        }

        const vehicle = await prisma.vehicle.findUnique({ where: { plate: patente } });
        if (vehicle) {
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) continue;

            try {
                // Check if WO exists? Using date + vehicle?
                // Legacy ID `id` (row[0]) is unique.
                // But WorkOrder doesn't have legacyId field.
                // We'll trust auto-increment. To prevent dupes on re-run, check if we want to store legacyId?
                // We didn't add legacyId to WorkOrder.
                // Risk of duplication on re-run.
                // For now, assume single run or check existence by loose match?
                // I'll skip existence check for now (assuming clean DB or I accept dupes/reset).
                // Or better: Add legacyId to WorkOrder? No, schema change required.
                // Let's rely on standard creation.

                const wo = await prisma.workOrder.create({
                    data: {
                        date: date,
                        finishedAt: date,
                        mileage: mileage,
                        price: 0, // Legacy doesn't have price sum easily
                        notes: notes,
                        status: 'COMPLETED',
                        clientId: vehicle.clientId,
                        vehicleId: vehicle.id,
                        serviceId: serviceRef.id
                    }
                });

                await SyncService.syncWorkOrder(wo);
                count++;
            } catch (e) {
                // console.error(e);
            }
        }
    }
    console.log(`Migrated ${count} service history records.`);
}
